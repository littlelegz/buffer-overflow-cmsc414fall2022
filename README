In this assignment, you will explore buffer overflows, as well as
some other attacks. Make sure that you test everything on the
official course VM.

Security Mechanisms

   * The C compiler uses a security mechanism called "Stack Guard",
     which detects and prevents buffer overflows. We have provided
     you with a Makefile that compiles your code with this disabled
     by default.

   * Additionally, the operating system performs address space
     randomization (ASLR), which does not prevent buffer overflows,
     but makes it much harder for them to result in a successful
     exploit. To disable this, run

        sudo sysctl -w kernel.randomize_va_space=0

     This will prompt you for your user password, unless you've
     configured your VM to allow password-less sudo. The "sudo"
     command allows a normal user to "do" a single command as the
     superuser (ie, root) "su". As the root user, you can edit the
     configuration file for this with the "visudo" command. The
     configuration file is /etc/sudoers (see the manpage for sudoers).

   * Finally, the bash shell provides some additional defenses. We
     are going to be exploiting "set-root-uid" executables, which
     allow a non-root user to perform an action with root privilege.
     When you run a program, you have a real uid (ruid) and an
     effective uid (euid). These are usually the same, except when
     you run a set-root-uid executable, in which case your euid
     becomes 0 (the root uid).

     If the program exits abnormally, it is unable to reset the
     euid to the user's ruid. In order to prevent the types of
     attacks we'll be exploring, bash checks the ruid and euid
     before spawning a shell. If these differ, it first drops its
     root privileges, setting euid back to ruid.

     For this reason, we will use the zsh shell in our exploits.

Part 1 -- Winning the Lottery

   The file lottery.c.tmpl contains a simple program that picks a
   random number, and compares it with a value selected by a function
   that you will write. Your task is to provide us with three
   different versions of this function that "win" the lottery 100%
   of the time. These functions do not have to employ buffer
   overflows, though they may.

   What to do:

      Copy lottery.c.tmpl to files lottery1.c, lottery2.c, and
      lottery3.c  In each of these, modify the function your_fcn()
      as you see fit. You may not modify main(). Hardcoding is
      allowed in this exercise.

      Success is defined by the program printing "You win!" (plus
      a newline) as its last line of output. We will run each program
      multiple times, and it must always win.

Part 2 -- Exploiting a Vulnerable Program

   We have provided you with a vulnerable program in stack.c -- you
   are not to modify this. The Makefile will compile this as needed
   to allow us to exploit it, including making it setuid-root.

   This program has a function bof(), which includes a buffer-overflow
   vulnerability. The program reads 517 bytes from a file named
   "badfile", and then uses strcpy() to write this into a buffer
   of length 32. The file will be your attack vector.

   What to do:

      Write a program named exploit_1.c that generates badfile. It will put
      the following at appropriate places in badfile:

       - shellcode
       - target address in the stack to which control should go
	 when bof() returns; ideally, the address of shellcode
       - NOP instructions to increase the chance of success

      exploit_1 should have exactly one command-line argument: the
      target address in hex format (eg, 0x1234abc). We have provided
      you with an initial skeleton for exploit_1.c

      Compile and run your program to generate badfile, and then
      run the vulnerable stack program. If your exploit is implemented
      correctly, then buf() returns it will execute your shellcode,
      giving you a root shell. If the target address is 0x1234abc,
      you would run

        $ make
        $ ./exploit_1 0x1234abc
        $ ./stack
        # <-- You've got a root shell!

   Note that when you've obtained a root shell, running "id" will
   reveal that while you have an euid of 0, your uid is still your
   non-root account. This difference matters for some programs.

